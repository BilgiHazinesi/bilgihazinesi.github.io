<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ä°kili MÄ±knatÄ±s EtkileÅŸimi | Bilgi Hazinesi</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #34495e;
            --accent: #e74c3c;
            --bg: #ecf0f1;
            --panel: #ffffff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none; /* Metin seÃ§imini engelle */
        }

        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            width: 100%;
            padding: 10px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.4rem; letter-spacing: 0.5px; }
        .subtitle { font-size: 0.85rem; opacity: 0.9; margin-top: 5px; }

        #controls {
            background: var(--panel);
            padding: 10px 20px;
            width: 95%;
            max-width: 1000px;
            display: flex;
            gap: 15px;
            border-radius: 0 0 10px 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #f7f9fa;
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
        }

        label { cursor: pointer; color: var(--primary); font-weight: 600; }
        input[type="checkbox"] { transform: scale(1.2); cursor: pointer; }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: var(--accent);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        button:hover { background-color: #c0392b; }

        #canvas-wrapper {
            position: relative;
            flex-grow: 1;
            width: 95%;
            max-width: 1200px;
            margin-bottom: 15px;
            background: #fff;
            border-radius: 8px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
            border: 2px solid #bdc3c7;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* Mobilde kaydÄ±rmayÄ± engelle */
        }

        .legend {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            border: 1px solid #ccc;
            pointer-events: none;
        }
        
        .magnet-label {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none; /* Canvas Ã¼zerine Ã§izdiÄŸimiz iÃ§in gizledik */
        }

    </style>
</head>
<body>

<header>
    <h1>ðŸ§² Ä°kili MÄ±knatÄ±s EtkileÅŸimi</h1>
    <div class="subtitle">MÄ±knatÄ±slarÄ± dÃ¶ndÃ¼rÃ¼n, yaklaÅŸtÄ±rÄ±n ve manyetik alanÄ± keÅŸfedin.</div>
</header>

<div id="controls">
    <div class="control-group">
        <input type="checkbox" id="showField" checked>
        <label for="showField">Alan Ã‡izgilerini GÃ¶ster (VektÃ¶rler)</label>
    </div>
    
    <div class="control-group">
        <input type="checkbox" id="showCompass" checked>
        <label for="showCompass">Gezgin PusulayÄ± GÃ¶ster</label>
    </div>

    <button onclick="resetSimulation()">ðŸ”„ KonumlarÄ± SÄ±fÄ±rla</button>
</div>

<div id="canvas-wrapper">
    <canvas id="simCanvas"></canvas>
    <div class="legend">
        <strong>Ä°puÃ§larÄ±:</strong><br>
        â€¢ MÄ±knatÄ±sÄ± taÅŸÄ±mak iÃ§in gÃ¶vdesinden tutun.<br>
        â€¢ DÃ¶ndÃ¼rmek iÃ§in âšª <b>beyaz halkadan</b> tutun.<br>
        â€¢ PusulayÄ± (sarÄ±) istediÄŸiniz yere sÃ¼rÃ¼kleyin.
    </div>
</div>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Kontrolleri
    const checkField = document.getElementById('showField');
    const checkCompass = document.getElementById('showCompass');

    let width, height;
    
    // Sabitler
    const MAGNET_W = 160;
    const MAGNET_H = 40;
    const POLE_OFFSET = MAGNET_W * 0.4; // KutuplarÄ±n merkezden uzaklÄ±ÄŸÄ±

    // Durum DeÄŸiÅŸkenleri
    let magnets = [];
    let compass = { x: 0, y: 0, r: 25, angle: 0, dragging: false };
    
    let draggingObj = null; // Åžu an sÃ¼rÃ¼klenen nesne (magnet body, magnet handle, compass)
    let dragType = null; // 'move', 'rotate', 'compass'
    let dragOffset = { x: 0, y: 0 };

    class Magnet {
        constructor(x, y, angle) {
            this.x = x;
            this.y = y;
            this.angle = angle; // Radyan cinsinden
            this.colorN = '#e74c3c'; // KÄ±rmÄ±zÄ±
            this.colorS = '#3498db'; // Mavi
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);

            // MÄ±knatÄ±s GÃ¶vdesi
            ctx.shadowBlur = 10;
            ctx.shadowColor = "rgba(0,0,0,0.2)";
            
            // S Kutbu (Sol) - Koordinat sistemine gÃ¶re Ã§izim
            ctx.fillStyle = this.colorS;
            ctx.fillRect(-MAGNET_W/2, -MAGNET_H/2, MAGNET_W/2, MAGNET_H);
            
            // N Kutbu (SaÄŸ)
            ctx.fillStyle = this.colorN;
            ctx.fillRect(0, -MAGNET_H/2, MAGNET_W/2, MAGNET_H);
            
            // YazÄ±lar (DÃ¶ndÃ¼rÃ¼lmÃ¼ÅŸ)
            ctx.fillStyle = "white";
            ctx.font = "bold 20px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("S", -MAGNET_W/4, 0);
            ctx.fillText("N", MAGNET_W/4, 0);

            // DÃ¶ndÃ¼rme Kolu (Handle) - N ucunun biraz ilerisinde
            ctx.beginPath();
            ctx.arc(MAGNET_W/2 + 20, 0, 10, 0, Math.PI*2);
            ctx.fillStyle = "white";
            ctx.fill();
            ctx.strokeStyle = "#7f8c8d";
            ctx.stroke(); // Ã‡erÃ§eve
            
            // Kola baÄŸlantÄ± Ã§izgisi
            ctx.beginPath();
            ctx.moveTo(MAGNET_W/2, 0);
            ctx.lineTo(MAGNET_W/2 + 10, 0);
            ctx.strokeStyle = "rgba(255,255,255,0.5)";
            ctx.stroke();

            ctx.restore();
        }

        // Basit manyetik model iÃ§in kutup pozisyonlarÄ±nÄ± global koordinatlarda dÃ¶ndÃ¼r
        getPoles() {
            // N kutbu pozisyonu
            const nx = this.x + Math.cos(this.angle) * POLE_OFFSET;
            const ny = this.y + Math.sin(this.angle) * POLE_OFFSET;
            // S kutbu pozisyonu
            const sx = this.x - Math.cos(this.angle) * POLE_OFFSET;
            const sy = this.y - Math.sin(this.angle) * POLE_OFFSET;
            return { nx, ny, sx, sy };
        }

        // TÄ±klama kontrolÃ¼
        hitTest(mx, my) {
            // Yerel koordinatlara Ã§evir
            const dx = mx - this.x;
            const dy = my - this.y;
            // Ters dÃ¶ndÃ¼r
            const localX = dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle);
            const localY = dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle);

            // GÃ¶vde kontrolÃ¼
            if (localX > -MAGNET_W/2 && localX < MAGNET_W/2 && 
                localY > -MAGNET_H/2 && localY < MAGNET_H/2) {
                return 'body';
            }
            
            // DÃ¶ndÃ¼rme kolu kontrolÃ¼
            // Kol merkezi localX = MAGNET_W/2 + 20, localY = 0
            const hx = MAGNET_W/2 + 20;
            const distHandle = Math.sqrt((localX - hx)**2 + (localY - 0)**2);
            if (distHandle < 15) return 'handle';

            return null;
        }
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        resetSimulation();
        loop();
    }

    function resize() {
        const wrapper = document.getElementById('canvas-wrapper');
        width = canvas.width = wrapper.offsetWidth;
        height = canvas.height = wrapper.offsetHeight;
    }

    function resetSimulation() {
        magnets = [];
        // Ä°ki mÄ±knatÄ±sÄ± karÅŸÄ±lÄ±klÄ± yerleÅŸtir
        magnets.push(new Magnet(width * 0.3, height/2, 0));
        magnets.push(new Magnet(width * 0.7, height/2, Math.PI)); // DiÄŸeri ters dursun
        
        compass.x = width/2;
        compass.y = height/2 - 100;
    }

    // Toplam Manyetik Alan VektÃ¶rÃ¼ Hesapla (B)
    function calculateB(x, y) {
        let Bx = 0, By = 0;
        
        magnets.forEach(m => {
            const poles = m.getPoles();
            
            // N Kutbundan (Ä°tme) - Kaynak pozitif
            const dxN = x - poles.nx;
            const dyN = y - poles.ny;
            const r2N = dxN*dxN + dyN*dyN;
            const rN = Math.sqrt(r2N);
            const forceN = 3000 / (rN * r2N); // 1/r^2 (vektÃ¶r normalize edilince 1/r^3)
            
            Bx += dxN * forceN;
            By += dyN * forceN;

            // S Kutbuna (Ã‡ekme) - Kaynak negatif
            const dxS = x - poles.sx;
            const dyS = y - poles.sy;
            const r2S = dxS*dxS + dyS*dyS;
            const rS = Math.sqrt(r2S);
            const forceS = 3000 / (rS * r2S);

            Bx -= dxS * forceS;
            By -= dyS * forceS;
        });

        return { x: Bx, y: By };
    }

    function drawField() {
        if (!checkField.checked) return;

        const gridStep = 40;
        ctx.strokeStyle = "rgba(44, 62, 80, 0.4)";
        ctx.lineWidth = 1;

        for (let x = 20; x < width; x += gridStep) {
            for (let y = 20; y < height; y += gridStep) {
                // MÄ±knatÄ±slarÄ±n Ã§ok yakÄ±nÄ±na Ã§izme
                let tooClose = false;
                magnets.forEach(m => {
                    const d = Math.sqrt((x-m.x)**2 + (y-m.y)**2);
                    if(d < 60) tooClose = true;
                });
                if(tooClose) continue;

                const B = calculateB(x, y);
                const angle = Math.atan2(B.y, B.x);
                const len = 15;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                
                // Ok Ã‡izimi
                ctx.beginPath();
                ctx.moveTo(-len/2, 0);
                ctx.lineTo(len/2, 0);
                // Ok ucu
                ctx.lineTo(len/4, -3);
                ctx.moveTo(len/2, 0);
                ctx.lineTo(len/4, 3);
                ctx.stroke();
                
                ctx.restore();
            }
        }
    }

    function drawCompass() {
        if (!checkCompass.checked) return;

        // PusulanÄ±n merkezindeki manyetik alan aÃ§Ä±sÄ±nÄ± bul
        const B = calculateB(compass.x, compass.y);
        // YumuÅŸak geÃ§iÅŸ iÃ§in aÃ§Ä±yÄ± direkt atamak yerine lerp yapÄ±labilir ama anlÄ±k tepki daha iyidir
        const targetAngle = Math.atan2(B.y, B.x);

        ctx.save();
        ctx.translate(compass.x, compass.y);
        
        // Pusula dÄ±ÅŸ Ã§erÃ§evesi
        ctx.shadowBlur = 5;
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.arc(0, 0, compass.r, 0, Math.PI*2);
        ctx.fillStyle = "#f1c40f"; // SarÄ± kasa
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#f39c12";
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Ä°ÄŸneyi dÃ¶ndÃ¼r
        ctx.rotate(targetAngle);

        // Ä°ÄŸne Ã‡izimi
        const needleLen = compass.r - 5;
        
        // KÄ±rmÄ±zÄ± uÃ§ (N - Manyetik alan yÃ¶nÃ¼nÃ¼ gÃ¶sterir)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(needleLen, 0);
        ctx.lineTo(0, -5);
        ctx.lineTo(0, 5);
        ctx.fillStyle = "red";
        ctx.fill();

        // Mavi uÃ§ (S)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-needleLen, 0);
        ctx.lineTo(0, -5);
        ctx.lineTo(0, 5);
        ctx.fillStyle = "blue";
        ctx.fill();

        // Merkez pimi
        ctx.beginPath();
        ctx.arc(0,0,3,0,Math.PI*2);
        ctx.fillStyle = "#333";
        ctx.fill();

        ctx.restore();
    }

    function loop() {
        ctx.clearRect(0, 0, width, height);

        drawField();
        magnets.forEach(m => m.draw(ctx));
        drawCompass();

        requestAnimationFrame(loop);
    }

    // --- EtkileÅŸim ---
    function handleStart(x, y) {
        // 1. Pusula kontrolÃ¼
        if (checkCompass.checked) {
            const dc = Math.sqrt((x - compass.x)**2 + (y - compass.y)**2);
            if (dc < compass.r) {
                draggingObj = compass;
                dragType = 'compass';
                dragOffset.x = x - compass.x;
                dragOffset.y = y - compass.y;
                return;
            }
        }

        // 2. MÄ±knatÄ±s kontrolÃ¼
        for (let m of magnets) {
            const hit = m.hitTest(x, y);
            if (hit) {
                draggingObj = m;
                dragType = hit; // 'body' veya 'handle'
                if (hit === 'body') {
                    dragOffset.x = x - m.x;
                    dragOffset.y = y - m.y;
                }
                return;
            }
        }
    }

    function handleMove(x, y) {
        if (!draggingObj) {
            // Mouse imleci deÄŸiÅŸtirme mantÄ±ÄŸÄ±
            let hover = false;
            // Pusula
            if (checkCompass.checked && Math.sqrt((x - compass.x)**2 + (y - compass.y)**2) < compass.r) hover = true;
            // MÄ±knatÄ±slar
            magnets.forEach(m => { if(m.hitTest(x,y)) hover = true; });
            canvas.style.cursor = hover ? 'pointer' : 'default';
            return;
        }

        if (dragType === 'compass') {
            draggingObj.x = x - dragOffset.x;
            draggingObj.y = y - dragOffset.y;
        } 
        else if (dragType === 'body') {
            draggingObj.x = x - dragOffset.x;
            draggingObj.y = y - dragOffset.y;
        } 
        else if (dragType === 'handle') {
            // DÃ¶ndÃ¼rme mantÄ±ÄŸÄ±
            const dx = x - draggingObj.x;
            const dy = y - draggingObj.y;
            draggingObj.angle = Math.atan2(dy, dx);
        }
    }

    function handleEnd() {
        draggingObj = null;
        dragType = null;
    }

    // Mouse Events
    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        handleStart(e.clientX - rect.left, e.clientY - rect.top);
    });
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        handleMove(e.clientX - rect.left, e.clientY - rect.top);
    });
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('mouseleave', handleEnd);

    // Touch Events
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        handleStart(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
    }, {passive: false});
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        handleMove(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
    }, {passive: false});
    canvas.addEventListener('touchend', handleEnd);

    // BaÅŸlat
    init();

</script>

</body>
</html>
