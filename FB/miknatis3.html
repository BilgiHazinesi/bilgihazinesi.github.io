<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CanlÄ± MÄ±knatÄ±s Deneyi - Fiziksel EtkileÅŸim</title>
    <style>
        :root {
            --bg-color: #ecf0f1;
            --magnet-red: #e74c3c;
            --magnet-blue: #3498db;
            --panel-bg: #ffffff;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        header {
            background-color: #2c3e50;
            color: white;
            width: 100%;
            padding: 10px 0;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 10;
        }

        h2 { margin: 0; font-size: 1.2rem; }
        p { margin: 5px 0 0; font-size: 0.9rem; opacity: 0.8; }

        #canvas-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            cursor: default;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9rem;
            transition: transform 0.1s;
        }
        
        button:active { transform: scale(0.95); }
        .btn-add { background: #27ae60; color: white; }
        .btn-reset { background: #c0392b; color: white; }
        .btn-field { background: #f39c12; color: white; }

        .hint {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.85rem;
            pointer-events: none;
            max-width: 250px;
        }
    </style>
</head>
<body>

<header>
    <h2>ðŸ§² Dinamik MÄ±knatÄ±s EtkileÅŸimi</h2>
    <p>MÄ±knatÄ±slarÄ± serbest bÄ±rakÄ±n, birbirlerini itip Ã§ektiklerini izleyin.</p>
</header>

<div id="canvas-container">
    <canvas id="simCanvas"></canvas>
    <div class="hint">
        <strong>NasÄ±l Ã‡alÄ±ÅŸÄ±r?</strong><br>
        â€¢ MÄ±knatÄ±slarÄ± tutup sÃ¼rÃ¼kleyin.<br>
        â€¢ BÄ±raktÄ±ÄŸÄ±nÄ±zda fizik kurallarÄ± devreye girer.<br>
        â€¢ AynÄ± kutuplar iter, zÄ±t kutuplar Ã§eker ve dÃ¶ner.
    </div>
    <div id="controls">
        <button class="btn-add" onclick="addMagnet()">âž• MÄ±knatÄ±s Ekle</button>
        <button class="btn-field" onclick="toggleField()">GÃ¶rÃ¼nmez AlanÄ± AÃ§/Kapa</button>
        <button class="btn-reset" onclick="resetSim()">ðŸ”„ SÄ±fÄ±rla</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    let width, height;

    // --- FÄ°ZÄ°K AYARLARI ---
    const SETTINGS = {
        friction: 0.92,       // SÃ¼rtÃ¼nme (0-1 arasÄ±, 1=sÃ¼rtÃ¼nme yok)
        angFriction: 0.85,    // DÃ¶nme sÃ¼rtÃ¼nmesi
        forceStrength: 1500,  // Ã‡ekim gÃ¼cÃ¼ katsayÄ±sÄ±
        maxSpeed: 15,         // Maksimum hÄ±z limiti
        magnetW: 140,         // MÄ±knatÄ±s geniÅŸliÄŸi
        magnetH: 40,          // MÄ±knatÄ±s yÃ¼ksekliÄŸi
        showField: false      // Alan Ã§izgileri baÅŸlangÄ±Ã§ta kapalÄ±
    };

    let magnets = [];
    let draggedMagnet = null;
    let dragOffset = { x: 0, y: 0, angleOffset: 0 };
    
    // Basit VektÃ¶r Ä°ÅŸlemleri
    const Vec2 = {
        add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }),
        sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),
        mag: (v) => Math.sqrt(v.x * v.x + v.y * v.y),
        normalize: (v) => {
            const m = Math.sqrt(v.x * v.x + v.y * v.y);
            return m === 0 ? {x:0, y:0} : { x: v.x/m, y: v.y/m };
        },
        rotate: (v, angle) => ({
            x: v.x * Math.cos(angle) - v.y * Math.sin(angle),
            y: v.x * Math.sin(angle) + v.y * Math.cos(angle)
        })
    };

    class Magnet {
        constructor(x, y, angle) {
            // Konum ve AÃ§Ä±
            this.x = x;
            this.y = y;
            this.angle = angle || 0;

            // HÄ±zlar
            this.vx = 0;
            this.vy = 0;
            this.angVel = 0; // AÃ§Ä±sal hÄ±z

            // Fiziksel Ã–zellikler
            this.w = SETTINGS.magnetW;
            this.h = SETTINGS.magnetH;
            this.mass = 2;
            this.inertia = 5000; // DÃ¶nmeye karÅŸÄ± direnÃ§
        }

        // KutuplarÄ±n dÃ¼nya koordinatlarÄ±nÄ± dÃ¶ndÃ¼rÃ¼r
        getPoles() {
            // Merkezden kutuplara olan mesafe (yarÄ± boydan biraz az)
            const dist = this.w * 0.4; 
            
            // N kutbu (+x yÃ¶nÃ¼nde yerel olarak)
            const nLoc = { x: dist, y: 0 };
            const nWorld = Vec2.add({x: this.x, y: this.y}, Vec2.rotate(nLoc, this.angle));

            // S kutbu (-x yÃ¶nÃ¼nde yerel olarak)
            const sLoc = { x: -dist, y: 0 };
            const sWorld = Vec2.add({x: this.x, y: this.y}, Vec2.rotate(sLoc, this.angle));

            return { n: nWorld, s: sWorld };
        }

        update() {
            if (this === draggedMagnet) {
                this.vx = 0; 
                this.vy = 0;
                this.angVel = 0;
                return;
            }

            // HÄ±zlarÄ± konuma ekle
            this.x += this.vx;
            this.y += this.vy;
            this.angle += this.angVel;

            // SÃ¼rtÃ¼nme (YavaÅŸlatma)
            this.vx *= SETTINGS.friction;
            this.vy *= SETTINGS.friction;
            this.angVel *= SETTINGS.angFriction;

            // Ekran sÄ±nÄ±rlarÄ±ndan sektirme
            if (this.x < this.w/2) { this.x = this.w/2; this.vx *= -0.5; }
            if (this.x > width - this.w/2) { this.x = width - this.w/2; this.vx *= -0.5; }
            if (this.y < this.h/2) { this.y = this.h/2; this.vy *= -0.5; }
            if (this.y > height - this.h/2) { this.y = height - this.h/2; this.vy *= -0.5; }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);

            // GÃ¶lge
            ctx.shadowBlur = 15;
            ctx.shadowColor = "rgba(0,0,0,0.2)";

            // S Kutbu (Mavi - Sol)
            ctx.fillStyle = "#3498db";
            ctx.fillRect(-this.w/2, -this.h/2, this.w/2, this.h);
            
            // N Kutbu (KÄ±rmÄ±zÄ± - SaÄŸ)
            ctx.fillStyle = "#e74c3c";
            ctx.fillRect(0, -this.h/2, this.w/2, this.h);

            // Kutup Harfleri
            ctx.shadowBlur = 0;
            ctx.fillStyle = "white";
            ctx.font = "bold 20px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // MÄ±knatÄ±s dÃ¶ndÃ¼kÃ§e harfler de dÃ¶ner ama okunaklÄ± kalsÄ±n diye save/restore yapÄ±labilir
            // Burada basitÃ§e mÄ±knatÄ±sla beraber dÃ¶nÃ¼yorlar
            ctx.fillText("S", -this.w/4, 0);
            ctx.fillText("N", this.w/4, 0);

            // Merkez noktasÄ± (opsiyonel)
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            ctx.beginPath();
            ctx.arc(0,0,5,0,Math.PI*2);
            ctx.fill();

            ctx.restore();
        }

        // TÄ±klama kontrolÃ¼ (Basit OBB kontrolÃ¼ yerine bounding radius kullanÄ±yoruz, performans iÃ§in yeterli)
        contains(mx, my) {
            // NoktayÄ± mÄ±knatÄ±sÄ±n yerel koordinatlarÄ±na Ã§evir
            const dx = mx - this.x;
            const dy = my - this.y;
            // Ters dÃ¶ndÃ¼r
            const localX = dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle);
            const localY = dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle);

            return (localX > -this.w/2 && localX < this.w/2 && 
                    localY > -this.h/2 && localY < this.h/2);
        }
    }

    function init() {
        resize();
        window.addEventListener('resize', resize);
        
        // BaÅŸlangÄ±Ã§ta 2 mÄ±knatÄ±s ekle
        resetSim();
        
        loop();
    }

    function resize() {
        const container = document.getElementById('canvas-container');
        width = canvas.width = container.offsetWidth;
        height = canvas.height = container.offsetHeight;
    }

    function addMagnet() {
        // Rastgele pozisyon ama Ã§akÄ±ÅŸmayacak ÅŸekilde
        magnets.push(new Magnet(width/2 + (Math.random()*100-50), height/2 + (Math.random()*100-50), Math.random() * Math.PI));
    }

    function resetSim() {
        magnets = [];
        magnets.push(new Magnet(width * 0.3, height/2, 0));
        magnets.push(new Magnet(width * 0.7, height/2, Math.PI)); // DiÄŸeri ters dursun
    }

    function toggleField() {
        SETTINGS.showField = !SETTINGS.showField;
    }

    // --- FÄ°ZÄ°K HESAPLAMALARI (Motorun Kalbi) ---
    function applyMagneticForces() {
        for (let i = 0; i < magnets.length; i++) {
            for (let j = i + 1; j < magnets.length; j++) {
                const m1 = magnets[i];
                const m2 = magnets[j];
                
                if (m1 === draggedMagnet || m2 === draggedMagnet) continue; // SÃ¼rÃ¼kleneni etkileme

                const poles1 = m1.getPoles(); // n, s
                const poles2 = m2.getPoles(); // n, s

                // 4 EtkileÅŸim: N1-N2, N1-S2, S1-N2, S1-S2
                // N=+1, S=-1 gÃ¼cÃ¼nde varsayalÄ±m.
                // AynÄ± iÅŸaretler (+ *, - *) = + (Ä°tme)
                // ZÄ±t iÅŸaretler (+ *, - *) = - (Ã‡ekme)

                applyPoleForce(m1, poles1.n, m2, poles2.n, 1.0);  // Ä°tme
                applyPoleForce(m1, poles1.n, m2, poles2.s, -1.0); // Ã‡ekme
                applyPoleForce(m1, poles1.s, m2, poles2.n, -1.0); // Ã‡ekme
                applyPoleForce(m1, poles1.s, m2, poles2.s, 1.0);  // Ä°tme

                // Ã‡arpÄ±ÅŸma (Basit iÃ§ iÃ§e geÃ§me engelleme)
                resolveCollision(m1, m2);
            }
        }
    }

    function applyPoleForce(m1, p1, m2, p2, sign) {
        // Ä°ki kutup arasÄ± vektÃ¶r
        const dx = p1.x - p2.x;
        const dy = p1.y - p2.y;
        let distSq = dx*dx + dy*dy;
        let dist = Math.sqrt(distSq);

        // Ã‡ok yakÄ±nsa kuvveti sÄ±nÄ±rla (PatlamayÄ± Ã¶nle)
        if (dist < 10) dist = 10;

        // Kuvvet formÃ¼lÃ¼ (F ~ 1/r^2)
        const forceMag = (SETTINGS.forceStrength / distSq) * sign;
        
        const fx = (dx / dist) * forceMag;
        const fy = (dy / dist) * forceMag;

        // Kuvveti M1'e uygula
        m1.vx += fx / m1.mass;
        m1.vy += fy / m1.mass;

        // Tork M1 (Tork = r x F)
        // r vektÃ¶rÃ¼ (Merkezden kutuba)
        const rx1 = p1.x - m1.x;
        const ry1 = p1.y - m1.y;
        // 2D tork (cross product'Ä±n z bileÅŸeni)
        const torque1 = rx1 * fy - ry1 * fx;
        m1.angVel += torque1 / m1.inertia;


        // Kuvveti M2'ye uygula (Etki-Tepki: Kuvvet ters yÃ¶nlÃ¼)
        m2.vx -= fx / m2.mass;
        m2.vy -= fy / m2.mass;

        // Tork M2
        const rx2 = p2.x - m2.x;
        const ry2 = p2.y - m2.y;
        // Kuvvet ters olduÄŸu iÃ§in -fx, -fy kullanÄ±yoruz
        const torque2 = rx2 * (-fy) - ry2 * (-fx);
        m2.angVel += torque2 / m2.inertia;
    }

    function resolveCollision(m1, m2) {
        // Ã‡ok basit Ã§ember Ã§arpÄ±ÅŸmasÄ± yaklaÅŸÄ±mÄ±
        const dx = m1.x - m2.x;
        const dy = m1.y - m2.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const minDist = 80; // MÄ±knatÄ±slarÄ±n birbirine giremeyeceÄŸi mesafe

        if (dist < minDist) {
            const overlap = minDist - dist;
            const nx = dx / dist;
            const ny = dy / dist;

            // Birbirinden it
            const separationFactor = 0.1; // Yaylanma
            m1.vx += nx * overlap * separationFactor;
            m1.vy += ny * overlap * separationFactor;
            m2.vx -= nx * overlap * separationFactor;
            m2.vy -= ny * overlap * separationFactor;

            // HÄ±zlarÄ± biraz sÃ¶nÃ¼mle (Ã‡arpÄ±ÅŸma enerji kaybÄ±)
            m1.vx *= 0.9; m1.vy *= 0.9;
            m2.vx *= 0.9; m2.vy *= 0.9;
        }
    }

    // --- GÃ–RSEL EFEKT ---
    function drawFieldVisualization() {
        if (!SETTINGS.showField) return;
        
        ctx.strokeStyle = "rgba(44, 62, 80, 0.2)";
        ctx.lineWidth = 1;
        const step = 40;
        
        for(let x=20; x<width; x+=step) {
            for(let y=20; y<height; y+=step) {
                // Her noktadaki B alanÄ±nÄ± hesapla
                let bx = 0, by = 0;
                magnets.forEach(m => {
                    const poles = m.getPoles();
                    // N'den Ã§Ä±kan
                    let dx = x - poles.n.x; let dy = y - poles.n.y;
                    let r2 = dx*dx + dy*dy; let r = Math.sqrt(r2);
                    bx += (dx/r) / r2; by += (dy/r) / r2;
                    // S'ye giren
                    dx = x - poles.s.x; dy = y - poles.s.y;
                    r2 = dx*dx + dy*dy; r = Math.sqrt(r2);
                    bx -= (dx/r) / r2; by -= (dy/r) / r2;
                });

                const angle = Math.atan2(by, bx);
                ctx.beginPath();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.moveTo(-10, 0); ctx.lineTo(10, 0);
                ctx.moveTo(6, -3); ctx.lineTo(10, 0); ctx.lineTo(6, 3);
                ctx.stroke();
                ctx.rotate(-angle);
                ctx.translate(-x, -y);
            }
        }
    }

    function loop() {
        // 1. Temizle
        ctx.clearRect(0, 0, width, height);

        // 2. Fizik Hesapla (Birden fazla adÄ±m daha stabil yapar ama basit tutuyoruz)
        if (!draggedMagnet) {
             applyMagneticForces();
        } else {
             // SÃ¼rÃ¼klenen varken diÄŸerleri hala etkileÅŸime girsin mi? 
             // Evet, diÄŸerleri hareket edebilir.
             applyMagneticForces();
        }

        // 3. KonumlarÄ± GÃ¼ncelle
        magnets.forEach(m => m.update());

        // 4. Ã‡iz
        drawFieldVisualization();
        magnets.forEach(m => m.draw(ctx));

        requestAnimationFrame(loop);
    }

    // --- FARE ETKÄ°LEÅžÄ°MÄ° ---
    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // Ãœstteki mÄ±knatÄ±sÄ± seÃ§
        for (let i = magnets.length - 1; i >= 0; i--) {
            if (magnets[i].contains(mx, my)) {
                draggedMagnet = magnets[i];
                // SÃ¼rÃ¼kleme ofseti (mÄ±knatÄ±s merkezinden tutulan yere)
                dragOffset.x = mx - magnets[i].x;
                dragOffset.y = my - magnets[i].y;
                break;
            }
        }
    });

    canvas.addEventListener('mousemove', e => {
        if (draggedMagnet) {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            draggedMagnet.x = mx - dragOffset.x;
            draggedMagnet.y = my - dragOffset.y;
            
            // HÄ±zlarÄ± sÄ±fÄ±rla ki bÄ±rakÄ±nca fÄ±rlamasÄ±n
            draggedMagnet.vx = 0;
            draggedMagnet.vy = 0;
        }
    });

    const endDrag = () => { draggedMagnet = null; };
    canvas.addEventListener('mouseup', endDrag);
    canvas.addEventListener('mouseleave', endDrag);

    // Dokunmatik
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const t = e.touches[0];
        const mx = t.clientX - rect.left;
        const my = t.clientY - rect.top;

        for (let i = magnets.length - 1; i >= 0; i--) {
            if (magnets[i].contains(mx, my)) {
                draggedMagnet = magnets[i];
                dragOffset.x = mx - magnets[i].x;
                dragOffset.y = my - magnets[i].y;
                break;
            }
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (draggedMagnet) {
            const rect = canvas.getBoundingClientRect();
            const t = e.touches[0];
            draggedMagnet.x = (t.clientX - rect.left) - dragOffset.x;
            draggedMagnet.y = (t.clientY - rect.top) - dragOffset.y;
            draggedMagnet.vx = 0; draggedMagnet.vy = 0;
        }
    }, {passive: false});
    canvas.addEventListener('touchend', endDrag);

    // BaÅŸlat
    init();

</script>

</body>
</html>
